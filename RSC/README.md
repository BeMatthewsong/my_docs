# ☑️ 리액트 서버 컴포넌트
 
### 기존 서버사이드 렌더링의 한계
서버 사이드 렌더링은 정적 컨텐츠를 빠르게 제공하고 서버에 있는 데이터에 손쉽게 사용할 수 있는 반면 사용자 인터렉션에 따른 다양한 사용자 경험을 제공하기는 어렵다.

### 서버 컴포넌트
서버 컴포넌트란 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법이다. 
즉, 서버가 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 작업은 클라이언트인 브라우저에 수행된다. 
즉, 일부 컴포넌트는 클라이언트에서 일부 컴포넌트는 서버에서 렌더링되는 것이다.

그렇다면 클라이언트 컴포넌트는 서버 컴포넌트를 직접 import할 수 없지만 child로 서버 컴포넌트를 가질 수 있다. 이는 직렬화 과정에서 client 컴포넌트는 placeholder를 써서 우회되지만, 자손으로 있는 서버컴포넌트가 있다면 직렬화 과정에 포함되어 최종적으로 DOM 트리에 반영되기 때문이다. 만약 클라이언트가 서버 컴포넌트를 불러오게 된다면 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 방법이 없기 때문에 컴포넌트를 호출할 수 없다.

서버 컴포넌트는 아래와 같은 특징들을 가지고 있다.
- 서버 컴포넌트는 상태와 생명 주기를 가질 수 없다. 

그래서 상태와 상태 주기를 가질 수 있는 훅인 useState, useReducer, useEffect등의 훅을 사용할 수 없다. 
- Web API를 사용할 수 없다.
그래서 DOM API를 쓰거나 window.document 등에 접근할 수 없다.

- 데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async await로 접근할 수 있다. 또한 컴포넌트 자체가 async한 것도 가능해진다.

### 서버 컴포넌트 렌더링의 과정

서버가 렌더링 요청을 받는다.
1. 서버가 렌더링 과정을 수행하므로 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 렌더링이 시작된다. 

2. 서버는 받은 요청에 따라 컴포넌트를 직렬화한다. 이 과정에서 클라이언트 컴포넌트는 직렬화를 우회한다. 

3. 브라우저가 리액트 컴포넌트 트리를 구성한다. 브라우저가 서버를 통해 스트림 형태로 json결과물을 받았다면 이 구문을 다시 파싱해 트리를 재구성하고 컴포넌트를 만들어나간다. 이 과정에서 클라이어트 컴포넌트를 받았다면 클라이언트에서 렌더링을 진행하고 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리액트 트리를 만든다. 

4. 그리고 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋한다.

### 서버 컴포넌트의 장점
- 자유로운 서버 리소스 접근
- 제로 번들 사이즈 컴포넌트 (퍼포먼스 악영향을 없앰)
- 자동 코드 분할 (번들을 여러 개의 작은 번들로 쪼개어 필요할 때마다 클라이언트로 전송하는 방법)

## ☑️ 클라이언트 컴포넌트와 서버 컴포넌트
![image](https://github.com/final-project-temporaryName/youth_frontend/assets/98685266/040b28dd-6abf-4081-9473-17be868cdecb)

[[kakaopay] React 18: 리액트 서버 컴포넌트 준비하기](https://tech.kakaopay.com/post/react-server-components/)

## ☑️ 서버 사이드 렌더링과 서버 컴포넌트
- 서버사이드 렌더링은 응답받은 페이지 전체를 html로 렌더링하는 과정을 서버에서 수행한 후 클라이언트에 그 응답 결과를 내려준다. 이후 클라이언트에서 하이드레이션을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 작업을 수행한다. 다만 서버에서 렌더링한 html은 하이드레이션을 거치지 않은 정적인 html이다. 따라서 인터렉션이 불가능하므로 여전히 초기 html이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고 파싱하고 실행하는데 비용이 든다.

- 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 모두 서버에서 완성해 제공 받은 다음, 클라이언트 컴포넌트에서 서버 사이드 렌더링으로 초기 html을 빠르게 전달해주는 것도 가능하다.

## ☑️ Next.js에서의 리액트 서버 컴포넌트
과거 서버 사이드 렌더링에서는 요청 받은 페이지를 모두 렌더링해서 내려줄 때까지 사용자는 빈화면을 보게 되었는데 실제로 페이지를 다 받았다하더라도 사용자가 인터렉션할수없는 정적인 페이지고 리액트에서 하이드레이션을 거쳐야만 비로소 사용자의 인터렉션이 가능한 페이지가 된다. 

### Next.js의 스트리밍 기능
문제는 이 작업들이 모두 순차적으로 완료되어야했다는건데, 이를 해결하기 위해 progressive rendering 즉 html을 작은 단위로 쪼개서 완성되는 대로 클라이언트에 점진적으로 보내는 스트리밍이 도입됐다. 이걸 활용하면 모든 데이터가 로드될 때까지 기다리지 않더라도 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여주는 방법이 가능하다.

즉 사용자가 일부라도 페이지와 인터렉션을 할 수 있다는 것을 의미하고 TTFB(Time to first byte)와 최초 콘텐트풀 페인팅(FCP first contentful painting)을 개선하는데 큰 도움을 준다.

**즉 모든 컴포넌트를 기다리는 대신 컴포넌트가 완성되는 대로 클라이언트에 보내주기 때문에 사용자는 페이지가 완성될 때까지 기다리는 지루함을 덜 수 있고 페이지가 로딩 중이라는 인식을 더 명확하게 심어줄 수 있다.**

이 과정에서 (로딩 중) → 직접 **Suspense**를 사용하는 것도 동일한 혜택을 누릴 수 있다. 
아래 링크를 통해 더 살펴볼 수 있다.

[SSR 환경에서 Suspense 도입 시 발생할 수 있는 문제와 해결 방법](https://velog.io/@chchaeun/Skeleton-UI%EB%A1%9C-%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B2%BD%ED%97%98-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-with-Suspense)
